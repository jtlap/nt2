<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Motivation</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Dispatch 1.0">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Dispatch 1.0">
<link rel="prev" href="../index.html" title="Chapter&#160;1.&#160;Dispatch 1.0">
<link rel="next" href="defining_hierarchies.html" title="Defining hierarchies">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="defining_hierarchies.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="dispatch.motivation"></a><a class="link" href="motivation.html" title="Motivation">Motivation</a>
</h2></div></div></div>
<p>
      Let us consider a fairly artificial scenario, but representive of things that
      are quite common in generic programming: we want to define a unary function
      <code class="computeroutput"><span class="identifier">f</span></code>, for all built-in arithmetic
      types, that returns different values depending on the actual type of the argument.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          return 0 if it is floating point
        </li>
<li class="listitem">
          return 1 if it is a signed integer
        </li>
<li class="listitem">
          return 2 if it is an unsigned integer
        </li>
</ul></div>
<p>
      You could do this with two means: SFINAE or tag dispatching.
    </p>
<p>
      With SFINAE: 
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">enable_if</span><span class="special">&lt;</span>
    <span class="identifier">is_floating_point</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span>
    <span class="keyword">int</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">enable_if</span><span class="special">&lt;</span>
    <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">and_</span><span class="special">&lt;</span>
        <span class="identifier">is_signed</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span>
        <span class="identifier">is_integral</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
    <span class="special">&gt;,</span>
    <span class="keyword">int</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">enable_if</span><span class="special">&lt;</span>
    <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">and_</span><span class="special">&lt;</span>
        <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">not_</span><span class="special">&lt;</span> <span class="identifier">is_signed</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;,</span>
        <span class="identifier">is_integral</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
    <span class="special">&gt;,</span>
    <span class="keyword">int</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">2</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
    </p>
<p>
      Or, with tag dispatching: 
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">t</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">t</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">is_floating_point</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">(),</span> <span class="keyword">typename</span> <span class="identifier">is_signed</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">());</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><span class="special">,</span> <span class="identifier">U</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span><span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span><span class="special">,</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="number">2</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
    </p>
<p>
      The SFINAE approach clearly doesn't scale in terms of programming, since all
      overloads must be mutually exclusive, but also in terms of compile times, since
      SFINAE-based overload resolution is linear.
    </p>
<p>
      Tag dispatching, on the other hand, can be very good if rather than using
      <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span></code> / <code class="computeroutput"><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span></code>
      a hierarchy of inheriting types are used, allowing to make use of the best-match
      feature of C++ overloading to introduce specializations without requiring them
      to be mutually exclusive. <br> Doing this in a clean, concise, reusable and
      idiomatic manner is however of some difficulty, which is why that is only done
      in an ad-hoc way in practice.
    </p>
<p>
      Boost.Dispatch solves that problem by providing a generic way to do best-match
      selection, with an extensible hierarchy system that contains ready-made hierarchies
      and that can be easily extended.
    </p>
<p>
      
</p>
<pre class="programlisting"><span class="comment">// each function must have a type to be uniquely identified</span>
<span class="keyword">struct</span> <span class="identifier">f_</span> <span class="special">{};</span>

<span class="special">/</span> <span class="identifier">we</span> <span class="identifier">define</span> <span class="identifier">the</span> <span class="identifier">free</span> <span class="identifier">function</span> <span class="identifier">f</span><span class="special">,</span> <span class="identifier">that</span> <span class="keyword">for</span> <span class="identifier">now</span> <span class="identifier">only</span> <span class="identifier">does</span> <span class="identifier">a</span> <span class="keyword">static</span> <span class="identifier">assert</span>
<span class="identifier">BOOST_DISPATCH_FUNCTION_IMPLEMENTATION</span><span class="special">(</span><span class="identifier">f_</span><span class="special">,</span> <span class="identifier">f</span><span class="special">,</span> <span class="number">1</span><span class="special">)</span>

<span class="comment">// we define the specialization for real types</span>
<span class="identifier">BOOST_DISPATCH_FUNCTOR_IMPLEMENTATION</span><span class="special">(</span> <span class="special">(),</span>
    <span class="identifier">f_</span><span class="special">,</span>
    <span class="identifier">tag</span><span class="special">::</span><span class="identifier">cpu_</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">A0</span><span class="special">),</span>
    <span class="special">(</span><span class="identifier">scalar_</span><span class="special">&lt;</span> <span class="identifier">real_</span><span class="special">&lt;</span><span class="identifier">A0</span><span class="special">&gt;</span> <span class="special">&gt;)</span>
<span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">result_type</span><span class="special">;</span>
    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// we define the specialization for signed types</span>
<span class="identifier">BOOST_DISPATCH_FUNCTOR_IMPLEMENTATION</span><span class="special">(</span> <span class="special">(),</span>
    <span class="identifier">f_</span><span class="special">,</span>
    <span class="identifier">tag</span><span class="special">::</span><span class="identifier">cpu_</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">A0</span><span class="special">),</span>
    <span class="special">(</span><span class="identifier">scalar_</span><span class="special">&lt;</span> <span class="identifier">signed_</span><span class="special">&lt;</span><span class="identifier">A0</span><span class="special">&gt;</span> <span class="special">&gt;)</span>
<span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">result_type</span><span class="special">;</span>
    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// we define the specialization for unsigned types</span>
<span class="identifier">BOOST_DISPATCH_FUNCTOR_IMPLEMENTATION</span><span class="special">(</span> <span class="special">(),</span>
    <span class="identifier">f_</span><span class="special">,</span>
    <span class="identifier">tag</span><span class="special">::</span><span class="identifier">cpu_</span><span class="special">,</span>
    <span class="special">(</span><span class="identifier">A0</span><span class="special">),</span>
    <span class="special">(</span><span class="identifier">scalar_</span><span class="special">&lt;</span> <span class="identifier">unsigned_</span><span class="special">&lt;</span><span class="identifier">A0</span><span class="special">&gt;</span> <span class="special">&gt;)</span>
<span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">result_type</span><span class="special">;</span>
    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="number">2</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
    </p>
<p>
      Here, the second specialization applies to any signed scalar type, including
      floating-point ones. However, since there is also a specialization for real
      (i.e. floating point) types, the latter gets preferred, since <code class="computeroutput"><span class="identifier">real_</span></code> is a refinement of <code class="computeroutput"><span class="identifier">signed_</span></code>.
    </p>
<p>
      Additionally, with Boost.Dispatch, all specializations are registered in an
      ADL context. That means that you can introduce specializations after the function
      is used in template contexts and those new specializations will still get used
      when that code is instantiated. This is not the case with regular function
      overloads, which usually perform name lookup eagerly.
    </p>
<p>
      The approach also turns all incriminated functions into polymorphic function
      objects, which has a lot of uses in generic and functional programming.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2003-2011 LASMEA
      UMR 6602 CNRS/Univ. Clermont II<br>Copyright &#169; 2009-2011 LRI UMR 8623
      CNRS/Univ Paris Sud XI<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="defining_hierarchies.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
